name: Git Flow Sync & PR Checks

on:
  pull_request:
    types: [closed, opened, synchronize, reopened]
    branches:
      - main
      - development
      - 'feature/*'
      - 'release/*'
  push:
    branches:
      - feature/linting

permissions:
  contents: write
  pull-requests: write

jobs:
  block-merges:
    if: >
      github.event_name == 'pull_request' && 
      github.event.action == 'opened' &&
      (startsWith(github.event.pull_request.base.ref, 'feature/') || 
       startsWith(github.event.pull_request.base.ref, 'release/'))
    runs-on: ubuntu-latest
    steps:
      - name: Block merge to feature/* and release/* branches
        uses: actions/github-script@v7
        with:
          script: |
            const baseRef = context.payload.pull_request.base.ref;
            const headRef = context.payload.pull_request.head.ref;

            console.log(`âŒ MERGE BLOCKED!`);
            console.log(`âŒ Target branch: ${baseRef}`);
            console.log(`âŒ Source branch: ${headRef}`);
            console.log(`âŒ Merges to feature/* and release/* branches are not allowed in Git Flow!`);

            // Close the PR
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              state: 'closed'
            });

            // Add comment explaining why PR was closed
            await github.rest.issues.createComment({
              issue_number: context.payload.pull_request.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸš« **PR Automatically Closed - Git Flow Violation**
              
              This PR was automatically closed because merges to \`${baseRef}\` are not allowed in Git Flow.
              
              **Git Flow Rules:**
              - \`feature/*\` branches should only receive commits directly (no merges)
              - \`release/*\` branches should only receive commits directly (no merges)
              - Only \`development\` and \`main\` branches accept merges
              
              **What to do instead:**
              - If this is feature work: Create PR to \`development\` branch
              - If this is a release: Create PR from \`release/*\` to \`main\`
              - If this is a hotfix: Create PR from \`hotfix/*\` to \`main\`
              
              Please create a new PR with the correct target branch.`
            });

            // Create an issue to track this violation
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Git Flow Violation: Attempted merge to ${baseRef}`,
              body: `**Blocked PR Details:**
              - PR: #${context.payload.pull_request.number}
              - Source: \`${headRef}\`
              - Target: \`${baseRef}\`
              - Author: @${context.payload.pull_request.user.login}
              
              **Action Taken:** PR was automatically closed
              
              **Reminder:** Please follow Git Flow guidelines for branch merging.`,
              labels: ['git-flow-violation', 'blocked-merge']
            });

            core.setFailed(`Merge to ${baseRef} blocked - Git Flow violation`);

  sync:
    if: github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup and Sync
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Get info
          BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "ðŸ” Branch merged to main: $BRANCH"

          # Only allow hotfix/* and release/* to merge into main
          if [[ ! "$BRANCH" =~ ^(hotfix|release)/ ]]; then
            echo "âŒ INVALID MERGE TO MAIN!"
            echo "âŒ Branch: $BRANCH"
            echo "âŒ Only hotfix/* and release/* can merge to main"

            gh issue create \
              --title "ðŸš¨ Invalid merge to main: $BRANCH" \
              --body "Branch \`$BRANCH\` was merged to main but only hotfix/* and release/* are allowed!" \
              --label "git-flow-violation"

            exit 1
          fi

          echo "âœ… Valid branch: $BRANCH"
          echo "ðŸ”„ Starting sync: main â†’ development"

          git fetch origin
          git checkout development

          if git merge origin/main -m "Auto-sync: main â†’ development after $BRANCH"; then
            echo "âœ… Merge successful!"
            if git push origin development; then
              echo "ðŸŽ‰ Successfully synced main to development!"
            else
              echo "âŒ Push to development failed"
              exit 1
            fi
          else
            echo "âš ï¸ Merge conflicts detected - creating resolution PR..."

            git merge --abort

            SYNC_BRANCH="sync-conflict-${GITHUB_RUN_NUMBER}"
            git checkout -b $SYNC_BRANCH origin/main
            git push origin $SYNC_BRANCH

            gh pr create \
              --base development \
              --head $SYNC_BRANCH \
              --title "ðŸš¨ Sync Conflict: main â†’ development" \
              --body "Conflicts detected while syncing main to development after $BRANCH merge. Manual resolution needed."

            echo "âœ… Conflict resolution PR created"
          fi

  code-quality:
    name: Code Quality Checks (Non-blocking)
    runs-on: ubuntu-latest
    if: >
      (github.event_name == 'pull_request' || github.ref == 'refs/heads/feature/linting') &&
      !(startsWith(github.event.pull_request.base.ref, 'feature/') || 
        startsWith(github.event.pull_request.base.ref, 'release/'))
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm i --force

      - name: Run ESLint (Non-blocking)
        id: eslint
        run: |
          echo "Running ESLint..."

          # Run ESLint and capture exit code
          set +e  # Don't exit on error
          npm run lint > eslint-output.txt 2>&1
          ESLINT_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          echo "ESLint exit code: $ESLINT_EXIT_CODE"

          # Check if there were any issues based on exit code
          if [ $ESLINT_EXIT_CODE -eq 0 ]; then
            echo "eslint_status=âœ… Passed" >> $GITHUB_OUTPUT
            echo "eslint_summary=No ESLint issues found!" >> $GITHUB_OUTPUT
          else
            echo "eslint_status=âš ï¸ Issues Found" >> $GITHUB_OUTPUT
            
            # Count errors and warnings from output
            ERRORS=$(grep -c "error" eslint-output.txt || echo "0")
            WARNINGS=$(grep -c "warning" eslint-output.txt || echo "0")
            PROBLEMS=$(grep -o "[0-9]\+ problems" eslint-output.txt | head -1 | grep -o "[0-9]\+" || echo "unknown")
            
            if [ "$PROBLEMS" != "unknown" ]; then
              echo "eslint_summary=Found $PROBLEMS problems ($ERRORS errors, $WARNINGS warnings)" >> $GITHUB_OUTPUT
            else
              echo "eslint_summary=Found $ERRORS errors and $WARNINGS warnings" >> $GITHUB_OUTPUT
            fi
          fi

          # Always succeed to make it non-blocking
          exit 0
        continue-on-error: true

      - name: Upload ESLint results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: eslint-results
          path: eslint-output.txt
          retention-days: 7

      - name: Comment on PR with ESLint results
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            let eslintOutput = '';
            let eslintStatus = '${{ steps.eslint.outputs.eslint_status }}';
            let eslintSummary = '${{ steps.eslint.outputs.eslint_summary }}';

            // Try to read the ESLint output file
            try {
              if (fs.existsSync('eslint-output.txt')) {
                const fullOutput = fs.readFileSync('eslint-output.txt', 'utf8');
                
                // Truncate output if it's too long for GitHub comment
                if (fullOutput.length > 2000) {
                  eslintOutput = fullOutput.substring(0, 2000) + '\n\n... (output truncated - check artifacts for full results)';
                } else {
                  eslintOutput = fullOutput;
                }
              }
            } catch (error) {
              console.log('Could not read ESLint output:', error);
              eslintOutput = 'ESLint output could not be retrieved';
            }

            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ðŸ“‹ **ESLint Analysis')
            );

            const message = `ðŸ“‹ **ESLint Analysis Complete** (Non-blocking)

            **Status:** ${eslintStatus}
            **Summary:** ${eslintSummary}

            ${eslintOutput ? `
            <details>
            <summary>ðŸ“„ ESLint Output</summary>

            \`\`\`
            ${eslintOutput}
            \`\`\`

            </details>
            ` : ''}

            **To check locally:**
            \`\`\`bash
            npm run lint
            \`\`\`

            ${eslintStatus.includes('Issues') ? 
              'âš ï¸ **Please review and fix ESLint issues when possible.** While this won\'t block the PR, addressing these issues will improve code quality.' : 
              'ðŸŽ‰ **Great job!** No ESLint issues found.'
            }`;

            if (botComment) {
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: message
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: message
              });
            }

  # SonarQube Analysis Job - Self-Hosted Server (Non-blocking)
  sonarqube-analysis:
    name: SonarQube Code Analysis (Non-blocking)
    runs-on: ubuntu-latest
    if: >
      (github.event_name == 'pull_request' || github.ref == 'refs/heads/feature/linting') &&
      !(startsWith(github.event.pull_request.base.ref, 'feature/') || 
        startsWith(github.event.pull_request.base.ref, 'release/'))
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --force

      - name: Run unit tests with coverage
        id: coverage
        run: |
          echo "Running tests with coverage..."
          npm run test:cov || true

          # Always continue, even if tests fail
          echo "coverage_status=âœ… Completed" >> $GITHUB_OUTPUT
          exit 0
        continue-on-error: true

      - name: SonarQube Scan
        id: sonar_scan
        uses: SonarSource/sonarqube-scan-action@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: http://194.163.40.149:9000
        continue-on-error: true

      - name: Check Quality Gate (Non-blocking)
        id: quality_gate
        run: |
          echo "SonarQube analysis completed. Check the dashboard for quality gate status."
          echo "Dashboard URL: http://194.163.40.149:9000"

          # Try to get quality gate status, but don't fail if we can't
          echo "quality_gate_status=â„¹ï¸ Check Dashboard" >> $GITHUB_OUTPUT
          echo "This check is non-blocking - PR can proceed regardless of quality gate status"

          # Always succeed
          exit 0
        continue-on-error: true

      - name: Upload SonarQube results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sonarqube-results
          path: |
            .scannerwork/
            coverage/
          retention-days: 7
        continue-on-error: true

      - name: Comment PR with SonarQube results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let sonarResults = '';
            let qualityGateStatus = '${{ steps.quality_gate.outputs.quality_gate_status }}' || 'â„¹ï¸ Check Dashboard';
            let coverageStatus = '${{ steps.coverage.outputs.coverage_status }}' || 'â„¹ï¸ Completed';

            // Try to get more detailed information
            let dashboardUrl = 'http://194.163.40.149:9000';
            let additionalInfo = '';

            try {
              const reportPath = '.scannerwork/report-task.txt';
              if (fs.existsSync(reportPath)) {
                const reportContent = fs.readFileSync(reportPath, 'utf8');
                const extractedUrl = reportContent.match(/dashboardUrl=(.+)/)?.[1];
                
                if (extractedUrl) {
                  dashboardUrl = extractedUrl;
                }
              }
            } catch (error) {
              console.log('Could not read SonarQube report:', error);
            }

            // Try to read coverage summary if available
            try {
              if (fs.existsSync('coverage/lcov-report/index.html')) {
                additionalInfo += '\nðŸ“Š **Coverage report generated** - check artifacts for detailed coverage information';
              }
            } catch (error) {
              console.log('Could not check coverage files:', error);
            }

            sonarResults = `ðŸ“Š **SonarQube Analysis Complete** (Non-blocking)

            **Quality Gate Status:** ${qualityGateStatus}
            **Coverage Status:** ${coverageStatus}

            [ðŸ” View Detailed Report](${dashboardUrl})

            **Analysis includes:**
            - âœ… Code coverage metrics
            - ðŸ›¡ï¸ Security vulnerability scan  
            - ðŸ” Code smells detection
            - ðŸ“Š Technical debt analysis
            - ðŸ”„ Code duplication check
            ${additionalInfo}

            **ðŸ“ Note:** This analysis is non-blocking. The PR can be merged regardless of the quality gate status, but please review any issues found to maintain code quality.

            **Dashboard:** [View Full Results](${dashboardUrl})`;

            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const existingComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ðŸ“Š **SonarQube Analysis')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                comment_id: existingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: sonarResults
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: sonarResults
              });
            }
